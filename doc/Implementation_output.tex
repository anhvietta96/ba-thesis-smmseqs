After being collected, the hashed data from the target and query sequences are packaged as byte units, prioritizing hash values. They then get sorted individually using radix sort (see GTTL), resulting in two data vectors sorted by hash values which would then be merged value by value, skipping through unmatching blocks.

\begin{algorithm}[t]
\caption{Merging query and target data}
\label{code:merging_data}
\begin{tabular}{@{}l@{~}l}
\textbf{Input:}&query data \(query\)\\
               &target data \(target\)
\end{tabular}
\begin{algorithmic}
\State \(target\_idx \gets target.start\)
\State \(query\_idx \gets target.start\)
\While{\(target\_idx \neq target.end\) \(\land\) \(query\_idx \neq query.end\)}
\State \(target\_hashval \gets target[target\_idx].hashval\)
\State \(query\_hashval \gets query[query\_idx].hashval\)
\If{\(target\_hashval < query\_hashval\)} \Comment{Skipping on target vector}
\While{\(target[target\_idx].hashval = target\_hashval\)} 
\State \(target\_idx++\)
\EndWhile
\Else
\If{\(target\_hashval > query\_hashval\)} \Comment{Skipping on query vector}
\While{\(query[query\_idx].hashval\)} 
\State \(query\_idx++\)
\EndWhile
\Else \Comment{Match found}
\State \(target\_block\_end = target\_idx\) 
\While{\(target[target\_block\_end] = target\_hashval\)}
\State \(target\_block\_end++\)
\EndWhile
\State \(query\_block\_end = query\_idx\)
\While{\(query[query\_block\_end] = query\_hashval\)}
\State \(query\_block\_end++\)
\EndWhile
\State \(create\_matches([target\_idx,target\_block\_end),[query\_idx,query\_block\_end))\)
\EndIf
\EndIf
\EndWhile
\end{algorithmic}
\end{algorithm}

The merging process results in a vector of matches, represented again as byte units, containing respectively the sequence number of the match on the target, on the query, the diagonal number (difference between the target and query sequence position), and the query sequence position. These quartets are again sorted with radix sort to prepare for ungapped alignment stage.