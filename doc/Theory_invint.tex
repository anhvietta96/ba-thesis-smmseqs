The most basic recursive hashing algorithm uses the alphabet size as
radix and defines the transformer function such that it uniquely
maps every character $s$ to an integers in the interval
$[0,|\mathcal{A}|-1]$. For example, in nucleotide sequence we have
$(|\mathcal{A}|=r=4)$,
a possible mapping (which respect the alphabet order) would be:
\begin{center}
\begin{tabular}{c|c}
$u$ & $f(u)$\\
\hline
A & 0 \\
C & 1 \\
G & 2\\
T & 3
\end{tabular}
\end{center}
This type of hash function, as a whole, basically translates the sequence
to a $|\mathcal{A}|$-ary number (quaternary in nucleotide sequence),
expressed in
decimal value. The minimum value is thus 0 and the maximum value is
$(|\mathcal{A}|^k-1)$. For example, it holds $H(AAAA) = 0$ and
$H(TTTT) = 4^4-1 = 255$.
For applications on nucleotide sequences,
the algorithm could then be optimized further by considering the bit
representation of the numbers 0 to 3. So the transformer is written as
follows:
\begin{center}
\begin{tabular}{c|c}
$u$ & $f(u)$ \\
\hline
A & 00\\
C & 01\\
G & 10\\
T & 11
\end{tabular}
\end{center}
As a consequence, instead of
arithmetic operations such as multiplication and addition, one can
use bitwise operations such as shifting ($\rol$) and exclusive OR (\(\XOR\),
denoted by
$\oplus$), see the pseudocode in Algorithm \ref{IncrementallyComputeH}.

\begin{algorithm}[t]
\caption{Invertible Integer Hashing (bitwise)}
\label{code:bitwiseinvint}
\begin{tabular}{@{}l@{~}l}
\textbf{Input:}&sequence $s$ of length $n$\\
               &size of alphabet \(r\)\\
               &transformer function \(f\)\\
               &function \(\mathsf{process}\) processing hash values
\end{tabular}
\begin{algorithmic}
\State \(\Mask \gets \rol(1,2k)-1\)\Comment{Note: $\rol(a,b)$ describes the
shifting of $a$ by $b$ bits).}
\State \(\HashValue \gets 0\)
\For{\(i\) \textbf{from} 1 to $k$}\Comment{Compute 1st hash}
\State \(\HashValue = \rol(\HashValue,2)\)
\State \(\HashValue = \XOR(\HashValue,f(s[i]))\)
\EndFor
\State \(\mathsf{process}(\HashValue)\)
\For{\(j\) \textbf{from} $k+1$ to $n$}\Comment{Compute other hash values}
\State \(\HashValue = \rol(\HashValue,2)\)
\State \(\HashValue = \AND(\HashValue,\Mask)\)
\State \(\HashValue = \XOR(\HashValue,f(s[j]))\)
\State \(\mathsf{process}(\HashValue)\)
\EndFor
\end{algorithmic}
\end{algorithm}
The scheme is simple, easy to implement and fast. It is important to note
the use of the \(\AND\)-Operator and a bitmask in the pseudocode above.
The leftmost character \(a\), whose contribution is to be removed from the
hash value (see Equation \ref{IncrementallyComputeH})
is represented by the two most significant bits of the hash value.
So after shifting (to multiply by \(r\)), the removal is obtained
by using an \(\AND\)-Operation with a precomputed mask \(4^{r}-1\)
without even knowing character \(a\).
It is also essential to note that because each character is mapped exactly
onto two bits, the maximum size of the $k$-mer is limited. A 64-bit
structure could only handle the hash values of 32-mer before significant
information loss. And due to the same reason, the hash values are biased in
regards to the input. For example, with a nucleotide distribution heavily
biased on Guanine, which is encoded as 10 on two bits, it is expected to
observe a bias on 1 in every odd-numbered bits and on 0 in every
even-numbered.