Since the target database can be very large, a precise and efficient evaluation must be prioritized. In MMseqs2, at every residue position, relevant characters based on the user-chosen spaced seed are individually extracted from the target sequence to create a \(q\)-gram and then process these \(q\)-grams  as independent strings. This approach would incur a time complexity of \(O(q)\) to compute a hash value for each \(q\)-gram and for the complete sequence of length \(n\) this would sum up to $O((n-q+1)q)=O(nq)$.

But the \(q\)-grams are in fact not independent from each other. To create the next \(q\)-gram, one would only have to remove the first character of the previous \(q\)-gram and append the next character in the sequence. Assuming these operations are of constant time complexity, the whole process would require only $O(n+q)$ time.

This family of hashing algorithms allows efficiently enumerate hash values of all \(q\)-grams of a sequence. In order to achieve independence between hash values, the characters are usually assigned a weight, which might be expressed as $r^{q-1-i}$, where $r$, the radix, is a constant integer and $i$ is the position of the character in the $q$-gram. The calculation of a hash value from a \(q\)-gram \(w\) could then be expressed as follows:
\begin{align}
H(w) = \sum_{i=0}^{q-1}r^{q-1-i}w[i]\label{DefineHfunction}
\end{align}
where $w$ is a \(q\)-gram and $w[i]$ is the $i$-th character in $w$.
As a base case of the recursive algorithm, the hash value for the
first $q$-gram of the sequence is computed in \(O(k)\) time by evaluating
the sum defined in Equation (\ref{DefineHfunction}).
Provided we have calculated the hash value of the previous $q$-gram
\(ax\), where \(a\) is a character and \(x\) is a \((q-1)\)-gram.
Then the hash value
of the next \(q\)-gram could be computed from \(H(ax)\) and the next not yet
processed character, say \(c\). Firstly, the contribution of \(a\)
character is subtracted from the hash value. The virtual window is then
shifted right one character. This means that the weight of all characters
in \(x\) increases by a factor or \(r\). That is, we multiply by the radix.
Lastly, the new character \(c\) is added to the hash.
The hash value of \(xc\) is then calculated as follows:
\begin{align}
H(xc) = (H(ax)-r^{n-1}\cdot a)\cdot r+c\label{IncrementallyComputeH}
\end{align}
Equations (\ref{DefineHfunction}) and (\ref{IncrementallyComputeH})
provide the basic schema of recursive hashing. In implementation, the most basic form of the algorithm, called invertible integer encoding, is used, where \(r=|\mathcal{A}|\). The pseudocode for this schema is
outlined in Algorithm \ref{code:invint}.
\begin{algorithm}[t]
\caption{Invertible Integer Encoding}
\label{code:invint}
\begin{tabular}{@{}l@{~}l}
\textbf{Input:}&Encoded sequence $s$ of length $n$\\
               &alphabet size \(r=|\mathcal{A}|\)\\
\end{tabular}
\begin{algorithmic}
\State \(\HashValVec\gets []\)
\State \(\HashValue \gets 0\)
\For{\(i\) \textbf{from} 1 to $k$}\Comment{Compute 1st hash}
\State \(\HashValue \gets \HashValue \cdot r\)
\State \(\HashValue \gets \HashValue + s[i]\)
\EndFor
\State \(\HashValVec .append(\HashValue)\)
\For{\(j\) \textbf{from} 1 to $n-k$}\Comment{Compute other hash values}
\State \(\HashValue \gets \HashValue - r^{n-1}\cdot s[j]\)
\State \(\HashValue \gets \HashValue \cdot r\)
\State \(\HashValue \gets \HashValue + s[j+k]\)\
\State \(\HashValVec .append(\HashValue)\)
\EndFor
\end{algorithmic}
\end{algorithm}

In order to extend the schema to allow for spaced seeds, one could divide the seed into shorter blocks of \(q\)-grams, intertwined by blocks of "Don't Care". Each block can then be treated as individual \(q\)-gram with custom radix, and the complexity is then \(O(nb)\), where \(b\) is the number of blocks. Since the number of blocks is in worst case the weight itself, and in best case 1, recursive hashing has a same or faster time complexity than normal hashing approachs.